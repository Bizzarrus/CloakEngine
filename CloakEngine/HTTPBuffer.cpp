#include "stdafx.h"
#include "Engine/Compress/NetBuffer/HTTPBuffer.h"

#include "CloakEngine/Global/Connection.h"
#include "CloakEngine/Files/Compressor.h"

#include <sstream>
#include <algorithm>

namespace CloakEngine {
	namespace Engine {
		namespace Compress {
			namespace NetBuffer {
				constexpr char HTTP_VERSION[] = "HTTP/1.1";

				API::Helper::ISyncSection* g_syncCookies = nullptr;

				namespace URL {
					enum class InputType {
						DPOINT,
						SLASH,
						DOT,
						QUESTION,
						NUMBER,
						OTHER
					};
					enum State {
						PROTOCOLL,
						PROTOCOLL_E1,
						PROTOCOLL_E2,
						PORT,
						HOST,
						PATH,
						QUERY,
						INVALID,
					};
					constexpr State MACHINE[][static_cast<size_t>(InputType::OTHER) + 1] = {
						//						DPOINT			SLASH			DOT			QUESTION		NUMBER		OTHER
						/*PROTOCOLL*/		{	PROTOCOLL_E1,	PATH,			HOST,		INVALID,		PROTOCOLL,	PROTOCOLL,	},
						/*PROTOCOLL_E1*/	{	INVALID,		PROTOCOLL_E2,	INVALID,	INVALID,		INVALID,	INVALID,	},
						/*PROTOCOLL_E2*/	{	INVALID,		HOST,			INVALID,	INVALID,		INVALID,	INVALID,	},
						/*PORT*/			{	INVALID,		PATH,			INVALID,	QUERY,			PORT,		INVALID,	},
						/*HOST*/			{	PORT,			PATH,			HOST,		QUERY,			HOST,		HOST,		},
						/*PATH*/			{	INVALID,		PATH,			PATH,		QUERY,			PATH,		PATH,		},
						/*QUERY*/			{	QUERY,			QUERY,			QUERY,		INVALID,		QUERY,		QUERY,		},
						/*INVALID*/			{	INVALID,		INVALID,		INVALID,	INVALID,		INVALID,	INVALID,	},
					};
				}
				namespace Date {
					enum State {
						START,
						DAY_WAIT,
						DAY_1,
						DAY_2,
						MON_WAIT,
						YEAR_WAIT,
						YEAR_1,
						YEAR_2,
						YEAR_3,
						YEAR_4,
						HOUR_WAIT,
						HOUR_1,
						HOUR_2,
						MIN_WAIT,
						MIN_1,
						MIN_2,
						SEC_WAIT,
						SEC_1,
						SEC_2,

						//Day detection:
						DAY_M,
						DAY_MO,
						DAY_MON,
						DAY_T,
						DAY_TU,
						DAY_TUE,
						DAY_TH,
						DAY_THU,
						DAY_W,
						DAY_WE,
						DAY_WED,
						DAY_F,
						DAY_FR,
						DAY_FRI,
						DAY_S,
						DAY_SA,
						DAY_SAT,
						DAY_SU,
						DAY_SUN,

						//Month detection:
						MON_J,
						MON_JA,
						MON_JAN,
						MON_JU,
						MON_JUN,
						MON_JUL,
						MON_F,
						MON_FE,
						MON_FEB,
						MON_M,
						MON_MA,
						MON_MAR,
						MON_MAY,
						MON_A,
						MON_AP,
						MON_APR,
						MON_AU,
						MON_AUG,
						MON_S,
						MON_SE,
						MON_SEP,
						MON_O,
						MON_OC,
						MON_OCT,
						MON_N,
						MON_NO,
						MON_NOV,
						MON_D,
						MON_DE,
						MON_DEC,

						//GTM
						TM_G,
						TM_GM,
						TM_GMT,

						FINISHED,
						INVALID,
					};
					enum class InputType {
						SPACE,
						NUMBER,
						COMMA,
						SEPERATOR,

						//Letters (upper case)
						LU_M,
						LU_T,
						LU_W,
						LU_F,
						LU_S,
						LU_J,
						LU_A,
						LU_O,
						LU_N,
						LU_D,
						LU_G,

						//Letters(lower case)
						LL_O,
						LL_N,
						LL_U,
						LL_E,
						LL_W,
						LL_D,
						LL_H,
						LL_R,
						LL_I,
						LL_A,
						LL_T,
						LL_P,
						LL_C,
						LL_B,
						LL_Y,
						LL_G,
						LL_V,
						LL_L,

						UNKNOWN,
					};

					constexpr State MACHINE[][static_cast<size_t>(InputType::UNKNOWN) + 1] = {
						//					SPACE		NUMBER		COMMA		SEPERATOR	LU_M		LU_T		LU_W		LU_F		LU_S		LU_J		LU_A		LU_O		LU_N		LU_D		LU_G		LL_O		LL_N		LL_U		LL_E		LL_W		LL_D		LL_H		LL_R		LL_I		LL_A		LL_T		LL_P		LL_C		LL_B		LL_Y		LL_G		LL_V		LL_L		UNKNOWN
						/*START*/		{	START,		INVALID,	INVALID,	INVALID,	DAY_M,		DAY_T,		DAY_W,		DAY_F,		DAY_S,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_WAIT*/	{	DAY_WAIT,	DAY_1,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_1*/		{	INVALID,	DAY_2,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_2*/		{	MON_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_WAIT*/	{	MON_WAIT,	INVALID,	INVALID,	INVALID,	MON_M,		INVALID,	INVALID,	MON_F,		MON_S,		MON_J,		MON_A,		MON_O,		MON_N,		MON_D,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*YEAR_WAIT*/	{	YEAR_WAIT,	YEAR_1,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*YEAR_1*/		{	INVALID,	YEAR_2,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*YEAR_2*/		{	INVALID,	YEAR_3,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*YEAR_3*/		{	INVALID,	YEAR_4,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*YEAR_4*/		{	HOUR_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*HOUR_WAIT*/	{	HOUR_WAIT,	HOUR_1,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*HOUR_1*/		{	INVALID,	HOUR_2,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*HOUR_2*/		{	INVALID,	INVALID,	INVALID,	MIN_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MIN_WAIT*/	{	INVALID,	MIN_1,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MIN_1*/		{	INVALID,	MIN_2,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MIN_2*/		{	INVALID,	INVALID,	INVALID,	SEC_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*SEC_WAIT*/	{	INVALID,	SEC_1,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*SEC_1*/		{	INVALID,	SEC_2,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*SEC_2*/		{	TM_G,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						//Day detection:
						//					SPACE		NUMBER		COMMA		SEPERATOR	LU_M		LU_T		LU_W		LU_F		LU_S		LU_J		LU_A		LU_O		LU_N		LU_D		LU_G		LL_O		LL_N		LL_U		LL_E		LL_W		LL_D		LL_H		LL_R		LL_I		LL_A		LL_T		LL_P		LL_C		LL_B		LL_Y		LL_G		LL_V		LL_L		UNKNOWN
						/*DAY_M*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	DAY_MO,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_MO*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	DAY_MON,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_MON*/		{	INVALID,	INVALID,	DAY_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						/*DAY_T*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	DAY_TU,		INVALID,	INVALID,	INVALID,	DAY_TH,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_TU*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	DAY_TUE,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_TUE*/		{	INVALID,	INVALID,	DAY_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_TH*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	DAY_THU,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_THU*/		{	INVALID,	INVALID,	DAY_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						/*DAY_W*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	DAY_WE,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_WE*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	DAY_WED,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_WED*/		{	INVALID,	INVALID,	DAY_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						/*DAY_F*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	DAY_FR,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_FR*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	DAY_FRI,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_FRI*/		{	INVALID,	INVALID,	DAY_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						/*DAY_S*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	DAY_SU,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	DAY_SA,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_SA*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	DAY_SAT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_SAT*/		{	INVALID,	INVALID,	DAY_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_SU*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	DAY_SUN,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*DAY_SUN*/		{	INVALID,	INVALID,	DAY_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						//Month detection:
						//					SPACE		NUMBER		COMMA		SEPERATOR	LU_M		LU_T		LU_W		LU_F		LU_S		LU_J		LU_A		LU_O		LU_N		LU_D		LU_G		LL_O		LL_N		LL_U		LL_E		LL_W		LL_D		LL_H		LL_R		LL_I		LL_A		LL_T		LL_P		LL_C		LL_B		LL_Y		LL_G		LL_V		LL_L		UNKNOWN
						/*MON_J*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_JU,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_JA,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_JA*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_JAN,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_JAN*/		{	YEAR_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_JU*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_JUN,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_JUL,	INVALID	},
						/*MON_JUN*/		{	YEAR_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_JUL*/		{	YEAR_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						/*MON_F*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_FE,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_FE*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_FEB,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_FEB*/		{	YEAR_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						/*MON_M*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_MA,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_MA*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_MAR,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_MAY,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_MAR*/		{	YEAR_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_MAY*/		{	YEAR_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						/*MON_A*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_AU,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_AP,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_AP*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_APR,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_APR*/		{	YEAR_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_AU*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_AUG,	INVALID,	INVALID,	INVALID	},
						/*MON_AUG*/		{	YEAR_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						/*MON_S*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_SE,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_SE*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_SEP,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_SEP*/		{	YEAR_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						/*MON_O*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_OC,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_OC*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_OCT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_OCT*/		{	YEAR_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						/*MON_N*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_NO,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_NO*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_NOV,	INVALID,	INVALID	},
						/*MON_NOV*/		{	YEAR_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						/*MON_D*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_DE,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_DE*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	MON_DEC,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*MON_DEC*/		{	YEAR_WAIT,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						//GTM
						//					SPACE		NUMBER		COMMA		SEPERATOR	LU_M		LU_T		LU_W		LU_F		LU_S		LU_J		LU_A		LU_O		LU_N		LU_D		LU_G		LL_O		LL_N		LL_U		LL_E		LL_W		LL_D		LL_H		LL_R		LL_I		LL_A		LL_T		LL_P		LL_C		LL_B		LL_Y		LL_G		LL_V		LL_L		UNKNOWN
						/*TM_G*/		{	TM_G,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	TM_GM,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*TM_GM*/		{	INVALID,	INVALID,	INVALID,	INVALID,	TM_GMT,		INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*TM_GMT*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	FINISHED,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						/*FINISHED*/	{	FINISHED,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},
						/*INVALID*/		{	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID,	INVALID	},

						//					SPACE		NUMBER		COMMA		SEPERATOR	LU_M		LU_T		LU_W		LU_F		LU_S		LU_J		LU_A		LU_O		LU_N		LU_D		LU_G		LL_O		LL_N		LL_U		LL_E		LL_W		LL_D		LL_H		LL_R		LL_I		LL_A		LL_T		LL_P		LL_C		LL_B		LL_Y		LL_G		LL_V		LL_L		UNKNOWN
					};

					bool CLOAK_CALL CalculateDate(In const std::string& dateString, Out API::Global::Date* date)
					{
						State curS = START;
						State lastS = curS;
						uint32_t year = 0;
						uint32_t month = 0;
						uint32_t day = 0;
						uint32_t hour = 0;
						uint32_t minute = 0;
						uint32_t second = 0;

						for (size_t a = 0; a < dateString.length(); a++)
						{
							const char c = dateString[a];
							InputType it = InputType::UNKNOWN;
							switch (c)
							{
								case ' ': it = InputType::SPACE; break;
								case '0':
								case '1':
								case '2':
								case '3':
								case '4':
								case '5':
								case '6':
								case '7':
								case '8':
								case '9': it = InputType::NUMBER; break;
								case ',': it = InputType::COMMA; break;
								case ':': it = InputType::SEPERATOR; break;

								//Upper letters:
								case 'M': it = InputType::LU_M; break;
								case 'T': it = InputType::LU_T; break;
								case 'W': it = InputType::LU_W; break;
								case 'F': it = InputType::LU_F; break;
								case 'S': it = InputType::LU_S; break;
								case 'J': it = InputType::LU_J; break;
								case 'A': it = InputType::LU_A; break;
								case 'O': it = InputType::LU_O; break;
								case 'N': it = InputType::LU_N; break;
								case 'D': it = InputType::LU_D; break;
								case 'G': it = InputType::LU_G; break;

								//Lower letters:
								case 'o': it = InputType::LL_O; break;
								case 'n': it = InputType::LL_N; break;
								case 'u': it = InputType::LL_U; break;
								case 'e': it = InputType::LL_E; break;
								case 'w': it = InputType::LL_W; break;
								case 'd': it = InputType::LL_D; break;
								case 'h': it = InputType::LL_H; break;
								case 'r': it = InputType::LL_R; break;
								case 'i': it = InputType::LL_I; break;
								case 'a': it = InputType::LL_A; break;
								case 't': it = InputType::LL_T; break;
								case 'p': it = InputType::LL_P; break;
								case 'c': it = InputType::LL_C; break;
								case 'b': it = InputType::LL_B; break;
								case 'y': it = InputType::LL_Y; break;
								case 'g': it = InputType::LL_G; break;
								case 'v': it = InputType::LL_V; break;
								case 'l': it = InputType::LL_L; break;
								default:						break;
							}
							lastS = curS;
							curS = MACHINE[curS][static_cast<size_t>(it)];
							switch (curS)
							{
								case DAY_1:
								case DAY_2:		day = (day * 10) + (c - '0'); break;
								case YEAR_1:
								case YEAR_2:
								case YEAR_3:
								case YEAR_4:	year = (year * 10) + (c - '0'); break;
								case HOUR_1:
								case HOUR_2:	hour = (hour * 10) + (c - '0'); break;
								case MIN_1:
								case MIN_2:		minute = (minute * 10) + (c - '0'); break;
								case SEC_1:
								case SEC_2:		second = (second * 10) + (c - '0'); break;
								case YEAR_WAIT:
									switch (lastS)
									{
										case MON_JAN:	month = 1; break;
										case MON_FEB:	month = 2; break;
										case MON_MAR:	month = 3; break;
										case MON_APR:	month = 4; break;
										case MON_MAY:	month = 5; break;
										case MON_JUN:	month = 6; break;
										case MON_JUL:	month = 7; break;
										case MON_AUG:	month = 8; break;
										case MON_SEP:	month = 9; break;
										case MON_OCT:	month = 10; break;
										case MON_NOV:	month = 11; break;
										case MON_DEC:	month = 12; break;
										default:
											break;
									}
									break;
								default:
									break;
							}
						}
						if (curS == FINISHED) 
						{ 
							*date = API::Global::Date(year, month, day, hour, minute, second); 
							return true;
						}
						return false;
					}
				}
				namespace Cookie {
					struct Entry {
						std::string Name;
						std::string Value;
						std::string File;
						bool AllowSubdomain;
						bool SeasonOnly;
						bool Secure;
						API::Global::Date Expire;
					};
					struct Domain {
						API::List<Entry> Cookies;
						API::HashMap<std::string, Domain*> Subdomains;
					};
					namespace DomainAlloc {
						struct Header {
							Header* Prev;
						};

						constexpr size_t MAX_PAGE_SIZE = 16 KB;
						constexpr size_t HEADER_SIZE = sizeof(Header);
						constexpr size_t NUM_ELEMENTS = (MAX_PAGE_SIZE - HEADER_SIZE) / sizeof(Domain);
						constexpr size_t PAGE_SIZE = (NUM_ELEMENTS * sizeof(Domain)) + HEADER_SIZE;

						size_t g_useCount = 0;
						Header* g_curPage = nullptr;

						Domain* CLOAK_CALL Allocate()
						{
							if (g_curPage == nullptr || g_useCount == NUM_ELEMENTS)
							{
								g_useCount = 0;
								Header* next = reinterpret_cast<Header*>(API::Global::Memory::MemoryHeap::Allocate(PAGE_SIZE));
								next->Prev = g_curPage;
								g_curPage = next;
							}
							void* r = reinterpret_cast<void*>(reinterpret_cast<uintptr_t>(g_curPage) + HEADER_SIZE + (g_useCount * sizeof(Domain)));
							g_useCount++;
							return new(r)Domain();
						}
						void CLOAK_CALL FreeAll()
						{
							Header* c = g_curPage;
							while (c != nullptr)
							{
								for (size_t a = 0; a < g_useCount; a++)
								{
									Domain* r = reinterpret_cast<Domain*>(reinterpret_cast<uintptr_t>(g_curPage) + HEADER_SIZE + (a * sizeof(Domain)));
									r->~Domain();
								}
								g_useCount = NUM_ELEMENTS;
								Header* o = c;
								c = o->Prev;
								API::Global::Memory::MemoryHeap::Free(o);
							}
							g_curPage = nullptr;
							g_useCount = 0;
						}
					}

					inline void CLOAK_CALL ExtractDomainList(In const std::string& host, In Domain* root, Out API::Stack<Domain*>* list, In_opt bool addDomains = false)
					{
						API::Helper::Lock lock(g_syncCookies);
						Domain* cur = root;
						if (cur != nullptr)
						{
							std::stringstream s;
							for (size_t a = 0; a <= host.length(); a++)
							{
								const char c = a < host.length() ? host[a] : '.';
								if (c == '.')
								{
									const std::string name = s.str();
									s.str("");
									Domain* next = nullptr;
									auto f = cur->Subdomains.find(name);
									if (f == cur->Subdomains.end())
									{
										if (addDomains == true)
										{
											next = DomainAlloc::Allocate();
											cur->Subdomains[name] = next;
										}
										else { next = nullptr; }
									}
									else { next = f->second; }
									cur = next;
									if (next != nullptr) { list->push(next); }
									else { break; }
								}
								else { s << c; }
							}
						}
					}
				}

				voidpf alloc_zlib(In voidpf op, In uInt items, In uInt size)
				{
					return API::Global::Memory::MemoryPool::Allocate(items*size);
				}
				void free_zlib(In voidpf op, In voidpf ptr)
				{
					API::Global::Memory::MemoryPool::Free(ptr);
				}
				inline bool CLOAK_CALL ProcessURL(In const std::string& url, In API::Files::HTTPMethod method, In uint16_t port, Out HTTP::Request* request)
				{
					CLOAK_ASSUME(request != nullptr);
					request->Method = method;
					request->Protocoll = HTTP::Protocoll::HTTP;
					URL::State curS = URL::PROTOCOLL;
					URL::State prev = curS;
					std::stringstream t;
					for (size_t a = 0; a < url.length(); a++)
					{
						const char c = url[a];
						URL::InputType it = URL::InputType::OTHER;
						switch (c)
						{
							case ':': it = URL::InputType::DPOINT; break;
							case '/': it = URL::InputType::SLASH; break;
							case '.': it = URL::InputType::DOT; break;
							case '?': it = URL::InputType::QUESTION; break;
							case '0':
							case '1':
							case '2':
							case '3':
							case '4':
							case '5':
							case '6':
							case '7':
							case '8':
							case '9': it = URL::InputType::NUMBER; break;
							default:
								break;
						}
						prev = curS;
						curS = URL::MACHINE[curS][static_cast<size_t>(it)];
						switch (curS)
						{
							case CloakEngine::Engine::Compress::NetBuffer::URL::PROTOCOLL_E1:
							{
								const std::string tmp = t.str();
								t.str("");
								if (tmp.compare("http") == 0) { request->Protocoll = HTTP::Protocoll::HTTP; }
								else { return false; }
								break;
							}
							case CloakEngine::Engine::Compress::NetBuffer::URL::PROTOCOLL:
								t << c;
								break;
							case CloakEngine::Engine::Compress::NetBuffer::URL::HOST:
							case CloakEngine::Engine::Compress::NetBuffer::URL::PORT:
							case CloakEngine::Engine::Compress::NetBuffer::URL::PATH:
							case CloakEngine::Engine::Compress::NetBuffer::URL::QUERY:
								if (curS == prev) { t << c; }
								else
								{	
									switch (prev)
									{
										case CloakEngine::Engine::Compress::NetBuffer::URL::PROTOCOLL:
										{
											switch (curS)
											{
												case CloakEngine::Engine::Compress::NetBuffer::URL::HOST: t << c; break;
												case CloakEngine::Engine::Compress::NetBuffer::URL::PORT:
												case CloakEngine::Engine::Compress::NetBuffer::URL::PATH:
												{
													const std::string tmp = t.str();
													t.str("");

													request->Host = tmp;
													break;
												}
												case CloakEngine::Engine::Compress::NetBuffer::URL::QUERY:
												default:
													CLOAK_ASSUME(false);
													break;
											}
											break;
										}
										case CloakEngine::Engine::Compress::NetBuffer::URL::PORT:
										{
											const std::string tmp = t.str();
											t.str("");

											try { port = std::stoi(tmp); }
											catch (...) { return false; }
											break;
										}
										case CloakEngine::Engine::Compress::NetBuffer::URL::HOST:
										{
											const std::string tmp = t.str();
											t.str("");

											request->Host = tmp;
											break;
										}
										case CloakEngine::Engine::Compress::NetBuffer::URL::PATH:
										{
											const std::string tmp = t.str();
											t.str("");

											request->File = tmp;
											break;
										}
										default:
											CLOAK_ASSUME(false);
											break;
									}
								}
								break;
							default:
								break;
						}
					}
					switch (curS)
					{
						case CloakEngine::Engine::Compress::NetBuffer::URL::PROTOCOLL:
						case CloakEngine::Engine::Compress::NetBuffer::URL::PROTOCOLL_E1:
						case CloakEngine::Engine::Compress::NetBuffer::URL::PROTOCOLL_E2:
							return false;
						case CloakEngine::Engine::Compress::NetBuffer::URL::PORT:
						{
							const std::string tmp = t.str();
							t.str("");
							try { port = std::stoi(tmp); }
							catch (...) { return false; }
							break;
						}
						case CloakEngine::Engine::Compress::NetBuffer::URL::HOST:
						{
							const std::string tmp = t.str();
							t.str("");
							request->Host = tmp;
							break;
						}
						case CloakEngine::Engine::Compress::NetBuffer::URL::PATH:
						{
							const std::string tmp = t.str();
							t.str("");
							request->File = tmp;
							break;
						}
						case CloakEngine::Engine::Compress::NetBuffer::URL::QUERY:
						{
							const std::string tmp = t.str();
							t.str("");
							request->Query = tmp;
							break;
						}
						default:
							break;
					}
					std::transform(request->Host.begin(), request->Host.end(), request->Host.begin(), tolower);
					std::transform(request->File.begin(), request->File.end(), request->File.begin(), tolower);
					if (request->Host.length() > 0) { request->Address = API::Global::Lobby::IPAddress(request->Host, port); }
					CloakDebugLog("HTTP: URL '" + url + "': Host = '" + request->Host + "' File = '" + request->File + "' Query = '" + request->Query + "'");
					size_t requestSize = request->File.length() + 1;
					if (request->Query.length() > 0 && request->Method == API::Files::HTTPMethod::GET) { requestSize += request->Query.length() + 1; }
					return curS != URL::INVALID && requestSize < 256;
				}

				CLOAK_CALL HTTPBuffer::HTTPBuffer() : m_callback(this)
				{
					DEBUG_NAME(HTTPBuffer);
					m_sync = nullptr;
					m_curCon = nullptr;
					m_net = nullptr;
					m_msgLength = 0;
					m_pos = 0;
					m_lastStatus = 0;
					m_inPos = 0;
					m_outPos = 0;
					m_outLength = 0;
					m_pending = 0;
					m_initEncoding = false;
					m_encoding = Encoding::Identity;
					m_curRequest.Host = "";
					m_curRequest.File = "";
					m_curRequest.Query = "";
					m_curReqID = 0;
					m_nextReqID = 1;
					m_updReqID = true;

					CREATE_INTERFACE(CE_QUERY_ARGS(&m_sync));
				}
				CLOAK_CALL HTTPBuffer::HTTPBuffer(In const std::string& address, In_opt uint16_t port, In_opt API::Files::HTTPMethod method) : HTTPBuffer()
				{
					Open(address, port, method);
				}
				CLOAK_CALL HTTPBuffer::~HTTPBuffer()
				{
					if (m_curCon != nullptr) { m_curCon->Close(); }
					if (m_initEncoding == true)
					{
						switch (m_encoding)
						{
							case HTTPBuffer::Encoding::GZIP:
								inflateEnd(&m_gzip);
								break;
							default:
								break;
						}
					}
					SAVE_RELEASE(m_sync);
					SAVE_RELEASE(m_net);
				}

				unsigned long long CLOAK_CALL_THIS HTTPBuffer::GetPosition() const { return m_pos; }
				uint8_t CLOAK_CALL_THIS HTTPBuffer::ReadByte()
				{
					API::Helper::Lock lock(m_sync);
					m_pos++;
					if (m_outPos < m_outLength)
					{
						const uint8_t r = m_outBuffer[m_outPos++];
						if (m_outPos == m_outLength) { iReadData(); }
						return r;
					}
					return 0;
				}
				bool CLOAK_CALL_THIS HTTPBuffer::HasNextByte()
				{
					API::Helper::Lock lock(m_sync);
					return m_outPos < m_outLength;
				}

				uint16_t CLOAK_CALL_THIS HTTPBuffer::GetStatusCode()
				{
					API::Helper::Lock lock(m_sync);
					return m_outPos < m_outLength || m_msgLength > 0 ? m_lastStatus : 0;
				}
				API::Files::RequestID CLOAK_CALL_THIS HTTPBuffer::Open(In const std::string& address, In_opt API::Files::HTTPMethod method, In_opt uint16_t port)
				{
					API::Helper::Lock lock(m_sync);
					HTTP::Request r;
					const bool s = ProcessURL(address, method, port, &r);
					if (CloakDebugCheckOK(s, API::Global::Debug::Error::CONNECT_HTTP_ERROR, false))
					{
						if (m_outPos >= m_outLength)
						{
							iRequest(r);
						}
						else
						{
							m_requests.push(r);
						}
						return m_nextReqID++;
					}
					return 0;
				}
				API::Files::RequestID CLOAK_CALL_THIS HTTPBuffer::Open(In const std::string& address, In uint16_t port, In_opt API::Files::HTTPMethod method)
				{
					return Open(address, method, port);
				}
				bool CLOAK_CALL_THIS HTTPBuffer::WaitForNextData()
				{
					API::Helper::Lock lock(m_sync);
					if (m_outPos < m_outLength) { return true; }
					if (m_pending == 0) { return false; }
					do {
						iReadHeader();
						if ((m_net == nullptr || m_net->HasNextByte() == false) && m_outPos >= m_outLength && m_pending > 0)
						{
							lock.unlock();
							lock.lock(m_sync, false); //Wait for further incoming messages
						}
					} while (m_outPos >= m_outLength && m_pending > 0);
					return m_outPos < m_outLength;
				}
				API::Files::RequestID CLOAK_CALL_THIS HTTPBuffer::GetRequestID() const
				{
					API::Helper::Lock lock(m_sync);
					return m_curReqID;
				}
				const std::string& CLOAK_CALL_THIS HTTPBuffer::GetHostName() const
				{
					API::Helper::Lock lock(m_sync);
					return m_curRequest.Host;
				}

				Success(return == true) bool CLOAK_CALL_THIS HTTPBuffer::iQueryInterface(In REFIID riid, Outptr void** ptr)
				{
					if (riid == __uuidof(API::Files::Buffer_v1::IHTTPReadBuffer)) { *ptr = (API::Files::Buffer_v1::IHTTPReadBuffer*)this; return true; }
					else if (riid == __uuidof(API::Files::Buffer_v1::IReadBuffer)) { *ptr = (API::Files::Buffer_v1::IReadBuffer*)this; return true; }
					else if (riid == __uuidof(API::Files::Buffer_v1::IBuffer)) { *ptr = (API::Files::Buffer_v1::IBuffer*)this; return true; }
					return SavePtr::iQueryInterface(riid, ptr);
				}
				void CLOAK_CALL_THIS HTTPBuffer::iReadHeader()
				{
					API::Helper::Lock lock(m_sync);
					if (m_net == nullptr || m_net->HasNextByte() == false) { return; }
					CLOAK_ASSUME(m_outPos >= m_outLength);
					CLOAK_ASSUME(m_msgLength == 0);
					if (m_initEncoding == true)
					{
						m_initEncoding = false;
						switch (m_encoding)
						{
							case HTTPBuffer::Encoding::GZIP:
								inflateEnd(&m_gzip);
								break;
							default:
								break;
						}
					}
					m_encoding = Encoding::Identity;
					HTTP::Request redirect;
					m_lastStatus = 0;
					m_pending--;
					std::stringstream line;
					size_t lineCount = 0;
					while (m_net->HasNextByte())
					{
						const char c = static_cast<char>(m_net->ReadByte());
						if (c == '\n' || c == '\0')
						{
							const std::string l = line.str();
							line.str("");

							if (l.length() == 0) { break; } //Header End
							if (lineCount == 0)
							{
								bool err = l.length() < ARRAYSIZE(HTTP_VERSION);
								for (size_t a = 0; a < ARRAYSIZE(HTTP_VERSION) - 1 && err == false; a++) { err = (l[a] != HTTP_VERSION[a]); }
								if (err || l[ARRAYSIZE(HTTP_VERSION) - 1] != ' ') { break; }
								const std::string status = l.substr(ARRAYSIZE(HTTP_VERSION), l.find_first_of(' ', ARRAYSIZE(HTTP_VERSION)));
								try { m_lastStatus = static_cast<uint16_t>(std::stoi(status)); }
								catch (...) { m_lastStatus = 0; }
								CloakDebugLog("HTTP: Status Code " + std::to_string(m_lastStatus));
							}
							else
							{
								CloakDebugLog("HTTP: Header: " + l);
								const size_t b = l.find_first_of(' ');
								if (b == l.npos) { lineCount = 0; break; }
								const std::string tag = l.substr(0, b - 1);
								const std::string value = l.substr(b + 1);
								if (tag.compare("Content-Length") == 0)
								{
									if (m_msgLength != 0) { lineCount = 0; break; }
									try {
										m_msgLength = static_cast<size_t>(std::stoi(value));
									}
									catch (...) {}
								}
								else if (tag.compare("Content-Encoding") == 0)
								{
									if (value.compare("gzip") == 0) { m_encoding = Encoding::GZIP; }
								}
								else if (tag.compare("Location") == 0)
								{
									if (ProcessURL(value, m_curRequest.Method, 80, &redirect) == false) { lineCount = 0; break; }
								}
								else if (tag.compare("Set-Cookie") == 0)
								{
									//TODO: Register cookie
								}
								else if (tag.compare("Content-Type") == 0)
								{
									//TODO
								}
							}
							lineCount++;
						}
						else if (c != '\r') { line << c; }
					}
					if (lineCount == 0)
					{
						CloakDebugLog("HTTP: Missing or malformed Header");
						if (m_curCon != nullptr) { m_curCon->Close(); }
						m_curCon = nullptr;
						SAVE_RELEASE(m_net);
						m_msgLength = 0;
						m_lastStatus = 0;
					}
					if (m_updReqID == true) { m_curReqID++; m_updReqID = false; }
					iReadData();
					if (m_lastStatus >= 300 && m_lastStatus < 400) //Redirect
					{ 
						if (m_lastStatus == 304)
						{
							//TODO: File not modfied and therefor not sent (cache)
						}
						else
						{
							if (m_lastStatus == 305)
							{
								redirect.Host = m_curRequest.Host;
								redirect.Query = m_curRequest.Query;
								redirect.File = m_curRequest.File;
								redirect.Protocoll = m_curRequest.Protocoll;
							}
							else if (m_lastStatus == 302 || m_lastStatus == 303) { redirect.Method = API::Files::HTTPMethod::GET; }
							iRequest(redirect);
						}
					}
					else if (m_requests.empty() == false) //Next request
					{
						const HTTP::Request next = m_requests.front();
						m_requests.pop();
						m_updReqID = true;
						iRequest(next);
					}
				}
				void CLOAK_CALL_THIS HTTPBuffer::iReadData()
				{
					API::Helper::Lock lock(m_sync);
					m_outPos = 0;
					if (m_encoding == Encoding::Identity)
					{
						m_outLength = min(m_msgLength, BUFFER_OUT_SIZE);
						for (size_t a = 0; a < m_outLength; a++) { m_outBuffer[a] = m_net->ReadByte(); }
						m_msgLength -= m_outLength;
					}
					else
					{
						size_t ins = m_inPos;
						for (size_t a = 0; a < m_msgLength && ins < BUFFER_IN_SIZE; a++, ins++) { m_inBuffer[ins] = m_net->ReadByte(); }
						m_msgLength -= ins - m_inPos;

						if (m_initEncoding == false)
						{
							m_initEncoding = true;
							switch (m_encoding)
							{
								case HTTPBuffer::Encoding::GZIP:
									memset(&m_gzip, 0, sizeof(z_stream));
									m_gzip.zalloc = alloc_zlib;
									m_gzip.zfree = free_zlib;
									m_gzip.opaque = nullptr;
									inflateInit2(&m_gzip, 32 + MAX_WBITS); //Automatic zlib/gzip header identification
									break;
								default:
									break;
							}
						}

						switch (m_encoding)
						{
							case HTTPBuffer::Encoding::GZIP:
							{
								m_gzip.avail_in = static_cast<uInt>(ins);
								m_gzip.avail_out = static_cast<uInt>(BUFFER_OUT_SIZE);
								m_gzip.next_in = m_inBuffer;
								m_gzip.next_out = m_outBuffer;
								const int ret = inflate(&m_gzip, Z_NO_FLUSH);
								CLOAK_ASSUME(ret != Z_STREAM_ERROR && ret != Z_MEM_ERROR);
								if (ret == Z_DATA_ERROR)
								{
									API::Global::Log::WriteToLog(static_cast<std::string>("HTTP: GZIP read error: ") + m_gzip.msg, API::Global::Log::Type::Warning);
									m_outLength = 0;
								}
								else
								{
									m_outLength = BUFFER_OUT_SIZE - m_gzip.avail_out;
									m_inPos = m_gzip.avail_in;
								}
								break;
							}
							default:
								break;
						}

						if (ins > 0)
						{
							CLOAK_ASSUME(m_inPos < ins);
							for (size_t a = ins - m_inPos, b = 0; a < ins; a++, b++) { m_inBuffer[b] = m_inBuffer[a]; }
						}
					}
				}
				void CLOAK_CALL_THIS HTTPBuffer::iRequest(In const HTTP::Request& request)
				{
					API::Helper::Lock lock(m_sync);
					m_pending++;
					if(m_curCon != nullptr && m_curRequest.Address == request.Address)
					{
						//Keep connection
						if (request.Host.length() == 0) { iRequestFile(m_curCon, request, m_curRequest.Host); }
						else { iRequestFile(m_curCon, request, request.Host); }
						m_curRequest.File = request.File;
						m_curRequest.Method = request.Method;
						m_curRequest.Protocoll = request.Protocoll;
						m_curRequest.Query = request.Query;
					}
					else if (request.Host.length() > 0)
					{
						//Require new connection
						if (m_curCon != nullptr)
						{
							m_curCon->Close();
							m_curCon = nullptr;
							SAVE_RELEASE(m_net);
						}
						m_curRequest = request;
						API::Global::Lobby::Connect(request.Address, API::Global::Lobby::TPType::TCP, &m_callback);
						//Request once the connection is established
					}
					else
					{
						CloakError(API::Global::Debug::Error::CONNECT_HTTP_HOST, false);
					}
				}
				void CLOAK_CALL_THIS HTTPBuffer::iRequestFile(In API::Global::IConnection* con, In const HTTP::Request& request, In const std::string& host)
				{
					CLOAK_ASSUME(con != nullptr);
					API::Files::IWriter* write = nullptr;
					CREATE_INTERFACE(CE_QUERY_ARGS(&write));
					API::Files::IWriteBuffer* wb = con->GetWriteBuffer();
					switch (request.Protocoll)
					{
						//TODO: HTTPS inject SSL buffer here
						case HTTP::Protocoll::HTTP: break;
						default: break;
					}
					write->SetTarget(wb, API::Files::CompressType::NONE, true);
					wb = nullptr;

					std::stringstream r;
					//Header:
					switch (request.Method)
					{
						case API::Files::HTTPMethod::GET:
						{
							r << "GET /" << request.File;
							if (request.Query.length() > 0) { r << "?" << request.Query; }
							r << " " << HTTP_VERSION << "\r\nContent-Length: 0";
							break;
						}
						case API::Files::HTTPMethod::POST:
						{
							r << "POST /" << request.File << " " << HTTP_VERSION;
							//TODO: Add post "Content-Length" field
							break;
						}
						default:
							break;
					}
					r << "\r\nHost: " << host << "\r\nAccept-Encoding: identity, gzip\r\n";
					//TODO: Add cookies
					r << "\r\n";

					//Body:
					if (request.Method == API::Files::HTTPMethod::POST)
					{
						//TODO: Add post body
					}


					//Send:
					write->WriteString(r.str());
					write->Save();
					SAVE_RELEASE(write);
					CloakDebugLog("HTTP: Sent request:\n" + r.str());
				}

				CLOAK_CALL HTTPBuffer::Callback::Callback(In HTTPBuffer* parent) : m_parent(parent)
				{
					
				}
				void CLOAK_CALL_THIS HTTPBuffer::Callback::OnConnect(In API::Global::IConnection* connection)
				{
					CloakDebugLog("HTTP: OnConnect");
					API::Helper::Lock lock(m_parent->m_sync);
					CLOAK_ASSUME(m_parent->m_curCon == nullptr);
					m_parent->m_curCon = connection;
					API::Files::IReadBuffer* rb = connection->GetReadBuffer();
					switch (m_parent->m_curRequest.Protocoll)
					{
						//TODO: HTTPS inject SSL buffer here
						case HTTP::Protocoll::HTTP: break;
						default: break;
					}
					SWAP(m_parent->m_net, rb);
					m_parent->iRequestFile(connection, m_parent->m_curRequest, m_parent->m_curRequest.Host);
				}
				void CLOAK_CALL_THIS HTTPBuffer::Callback::OnReceiveData(In API::Global::IConnection* connection)
				{
					CloakDebugLog("HTTP: OnReceiveData");
					API::Helper::Lock lock(m_parent->m_sync);
					if (connection == m_parent->m_curCon) { m_parent->m_sync->signalAll(); }
				}
				void CLOAK_CALL_THIS HTTPBuffer::Callback::OnDisconnect(In API::Global::IConnection* connection)
				{
					CloakDebugLog("HTTP: OnDisconnect");
					API::Helper::Lock lock(m_parent->m_sync);
					if (connection == m_parent->m_curCon)
					{
						m_parent->m_curCon = nullptr;
						m_parent->m_sync->signalAll();
					}
				}

				uint64_t CLOAK_CALL_THIS HTTPBuffer::Callback::AddRef()
				{
					return m_parent->AddRef();
				}
				uint64_t CLOAK_CALL_THIS HTTPBuffer::Callback::Release()
				{
					return m_parent->Release();
				}
			}
		}
	}
}
